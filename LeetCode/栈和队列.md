ğŸš‘æ ˆå’Œé˜Ÿåˆ—ğŸš‘
=======
* [7.æ•´æ•°åè½¬](#æ•´æ•°åè½¬) 
* [9.å›æ–‡æ•°](#å›æ–‡æ•°)
* [20.æœ‰æ•ˆçš„æ‹¬å·](#æœ‰æ•ˆçš„æ‹¬å·) 
* [232.ç”¨æ ˆå®ç°é˜Ÿåˆ—](#ç”¨æ ˆå®ç°é˜Ÿåˆ—)
* [225.ç”¨é˜Ÿåˆ—å®ç°æ ˆ](#ç”¨é˜Ÿåˆ—å®ç°æ ˆ)
* [155.æœ€å°æ ˆ](#æœ€å°æ ˆ)   
* [150.é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼](#é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼)
* [394.å­—ç¬¦ä¸²è§£ç ](#å­—ç¬¦ä¸²è§£ç )
* [133.å…‹éš†å›¾](#å…‹éš†å›¾)
* [200.å²›å±¿æ•°é‡](#å²›å±¿æ•°é‡)
* [84.æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢](#æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢)
* [542.01çŸ©é˜µ](#01çŸ©é˜µ)
* [622.è®¾è®¡å¾ªç¯é˜Ÿåˆ—](#è®¾è®¡å¾ªç¯é˜Ÿåˆ—)

æ•´æ•°åè½¬
===============
[Leetcode](https://leetcode-cn.com/problems/reverse-integer/)ç»™å‡ºä¸€ä¸ª 32 ä½çš„æœ‰ç¬¦å·æ•´æ•°ï¼Œä½ éœ€è¦å°†è¿™ä¸ªæ•´æ•°ä¸­æ¯ä½ä¸Šçš„æ•°å­—è¿›è¡Œåè½¬
### è§£é¢˜æ€è·¯
* ä»ä½åˆ°é«˜ä½ä¾æ¬¡åŠ å…¥é˜Ÿåˆ—ï¼Œç„¶åè¾“å‡º
* æ³¨æ„åè½¬åçš„æº¢å‡ºé—®é¢˜
```cpp
int reverse(int x) {
    int rev=0;
    while(x!=0){
        if(rev>INT_MAX/10 || rev<INT_MIN/10) return 0;
        rev=rev*10+x%10;
         x/=10;
     }
     return rev;
}
```


å›æ–‡æ•°
=========
[Leetcode](https://leetcode-cn.com/problems/palindrome-number/)åˆ¤æ–­ä¸€ä¸ªæ•´æ•°æ˜¯å¦æ˜¯å›æ–‡æ•°ã€‚å›æ–‡æ•°æ˜¯æŒ‡æ­£åºï¼ˆä»å·¦å‘å³ï¼‰å’Œå€’åºï¼ˆä»å³å‘å·¦ï¼‰è¯»éƒ½æ˜¯ä¸€æ ·çš„æ•´æ•°ã€‚
### è§£é¢˜æ€è·¯
* ä¸€ä½æ•°ä¸€å®šæ˜¯å›æ–‡æ•°
* è´Ÿæ•°æˆ–è€…ä¸ªä½æ˜¯0çš„ä¸€å®šä¸æ˜¯å›æ–‡æ•°ã€‚
* åè½¬æ•´æ•°ï¼Œåªåè½¬åˆ°ä¸€åŠï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒï¼ˆå¯¹äºå¥‡æ•°ä¸ªæ•°å¾—å›æ–‡æ•°ï¼Œå»æ‰ä¸­é—´ä½å†æ¯”è¾ƒï¼‰
```cpp
    bool isPalindrome(int x) {
        if(x>=0 && x<=9)return true;
        if(x%10==0 || x<0)return false;
        int rev=0;
        while(x>rev){
            rev=rev*10+x%10;
            x/=10;
        }
        return rev/10==x || rev==x;
    }
```

æœ‰æ•ˆçš„æ‹¬å·
======
[Leetcode](https://leetcode-cn.com/problems/valid-parentheses/)ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ '('ï¼Œ')'ï¼Œ'{'ï¼Œ'}'ï¼Œ'['ï¼Œ']' ===çš„å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚
æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š
```
1. å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚
2. å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚
```
æ³¨æ„ç©ºå­—ç¬¦ä¸²å¯è¢«è®¤ä¸ºæ˜¯æœ‰æ•ˆå­—ç¬¦ä¸²ã€‚
### è§£é¢˜æ€è·¯
* ä¸ªæ•°ä¸ºå¥‡æ•°è‚¯å®šä¸å¯¹
* é¦–å­—ç¬¦ä¸ºå³ç¬¦å·è‚¯å®šä¸å¯¹
* é‡åˆ°å·¦ç¬¦å·å…¥æ ˆ
* é‡åˆ°å³ç¬¦å·ä¸æ ˆé¡¶å…ƒç´ è¿›è¡ŒåŒ¹é…ï¼Œé…å¯¹åˆ™å‡ºæ ˆï¼Œå¦åˆ™è¿”å›falseï¼Œæœ€åæ ˆç©ºäº†åˆ™è¯´æ˜æ˜¯æœ‰æ•ˆçš„
```cpp
     bool isValid(string s) {
        if(s.size()%2)return false;
        if(s[0]=='}' || s[0]==')' || s[0]==']') return false;
        stack<char> sck;
        for(int i=0;s[i]!='\0';++i){
            if(s[i]=='[' || s[i]=='{' || s[i]=='('){
                sck.push(s[i]);
            }else{
                if(s[i]=='}' && sck.top()!='{') return false;
                if(s[i]==']' && sck.top()!='[') return false;
                if(s[i]==')' && sck.top()!='(') return false;
                sck.pop();
            }
        } 
        return sck.empty();
    }
```


ç”¨æ ˆå®ç°é˜Ÿåˆ—
=========
[Leetcode](https://leetcode-cn.com/problems/implement-queue-using-stacks/)  
* æ ˆçš„é¡ºåºä¸ºåè¿›å…ˆå‡ºï¼Œè€Œé˜Ÿåˆ—çš„é¡ºåºä¸ºå…ˆè¿›å…ˆå‡ºã€‚
* ä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°é˜Ÿåˆ—ï¼Œä¸€ä¸ªå…ƒç´ éœ€è¦ç»è¿‡ä¸¤ä¸ªæ ˆæ‰èƒ½å‡ºé˜Ÿåˆ—
```cpp
class MyQueue {
public:   
    void push(int x) {
        stack1.push(x);
    }
    
    int pop() {
       if(stack2.empty()){                  //åªæœ‰å½“stack2ä¸ºç©ºæ—¶ï¼Œæ‰é‡æ–°åŠ è½½
            while(!stack1.empty()){         //stack1è£…å¡«åˆ°stack2
                stack2.push(stack1.top());  //c++ pop()å‡½æ•°è¿”å›å€¼é¢ä¸ºvoid
                stack1.pop();
            }
        }
        int res=stack2.top();
        stack2.pop();
        return res;
    }
    
    int peek() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        return stack2.top();
    }
    
    bool empty() {
        return stack1.empty() && stack2.empty();
    }
private:
    stack<int> stack1;
    stack<int> stack2;
};

```  

ç”¨é˜Ÿåˆ—å®ç°æ ˆ
============
æ–¹æ³•ä¸€
----------
[Leetcode](https://leetcode-cn.com/problems/implement-stack-using-queues/)  
* ä¸€ä¸ªé˜Ÿåˆ—  
* pushä¹‹å‰åˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºç©º
* ä¸ä¸ºç©ºåˆ™å°†å…ƒç´ æ’å…¥åˆ°å°¾éƒ¨ï¼Œå‰é¢çš„å…¨éƒ¨å¼¹å‡ºå†å»å…¥é˜Ÿ
* `push`æ—¶é—´å¤æ‚åº¦O(n),è€Œ`pop`çš„æ—¶é—´å¤æ‚åº¦O(1)    

```cpp
class MyStack {
public:
    MyStack() {}
    
    void push(int x) {
        if(queue1.empty()){
            queue1.push(x);
        }else{
            int cnt=queue1.size();
            queue1.push(x);
            while(cnt-->0){
                queue1.push(queue1.front());
                queue1.pop();
            }
        }
    }
    
    int pop() {
        int res=queue1.front();
        queue1.pop();
        return res;
    }
    
    int top() {
        return queue1.front();
    }
    
    bool empty() {
        return queue1.empty();
    }
private:
    queue<int> queue1;
};

```
æ–¹æ³•äºŒ
--------
* `push`æ—¶é—´å¤æ‚åº¦O(1),è€Œ`pop`çš„æ—¶é—´å¤æ‚åº¦O(n)  
```cpp
private:
    queue<int> q1; 
    void push(int x) {
        q1.push(x);
    }
    int pop() {
        queue<int>q2;
        while(q1.size()>1){
            q2.push(q1.front());
            q1.pop();
        }
        int res=q1.front();
        q1=q2;
        return res;
    }   
    int top() {
        queue<int>q2(q1);
        while(q1.size()>1){
            q1.pop();
        }
        int res=q1.front();
        q1=q2;
        return res;
    }
    bool empty() {
        return q1.empty();
    }
};
```
æœ€å°æ ˆ  
=============
[Leetcode](https://leetcode-cn.com/problems/min-stack/)  
* ç»´æŠ¤ä¸¤ä¸ªæ ˆï¼š`æ•°æ®æ ˆ` `æœ€å°æ ˆ`
* åŒæ­¥ç®€å•ï¼Œå¼‚æ­¥èŠ‚çœ`æœ€å°æ ˆ`ç©ºé—´
* å¼‚æ­¥ï¼šå½“æ–°æ’å…¥çš„å…ƒç´ æ¯”æœ€å°å€¼è¿˜å°ï¼ˆæˆ–ç›¸ç­‰ï¼‰æ—¶ï¼Œæ’å…¥æœ€å°æ ˆï¼Œå‡ºæ ˆæ—¶åªæœ‰å½“ä¸¤ä¸ªæ ˆæ ˆé¡¶å…ƒç´ ç›¸åŒæ—¶ï¼Œä¸¤ä¸ªæ ˆåŒæ—¶popï¼Œå¦åˆ™åªæœ‰`æ•°æ®æ ˆ`pop  
* åŒæ­¥ï¼šä¸¤ä¸ªæ ˆçš„å¤§å°å§‹ç»ˆç›¸åŒï¼Œåªæ˜¯`æœ€å°æ ˆ`æ¯æ¬¡éƒ½æ’å…¥å½“å‰æœ€å°å€¼ï¼Œå‡ºæ ˆæ—¶ä¸¤æ ˆåŒæ—¶pop  

```cpp
class MinStack {
public: 
    void push(int x) {
        dataStack.push(x);
        if(miniStack.empty()){
            miniStack.push(x);
        }else{
            int min=miniStack.top();
            if(min>=x){                         //ç›¸ç­‰æ—¶ä¹Ÿè¦æ’å…¥
                miniStack.push(x);
            }
        }
    }
    
    void pop() {
        if( dataStack.top()==miniStack.top()){  //åªæœ‰ç›¸ç­‰æ—¶æ‰åŒæ—¶å¼¹å‡ºå¦åˆ™åªå¼¹å‡ºdataStack
            dataStack.pop();
            miniStack.pop();
        }else{
            dataStack.pop();
        }
    }
    
    int top() {
        return dataStack.top();
    }
    
    int getMin() {
        return miniStack.top();
    }
private:
    stack<int> dataStack;
    stack<int> miniStack;
};

```

é€†æ³¢å…°è¡¨è¾¾å¼æ±‚å€¼
==============
[leetcode](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)æ ¹æ® é€†æ³¢å…°è¡¨ç¤ºæ³•ï¼Œæ±‚è¡¨è¾¾å¼çš„å€¼ã€‚
æœ‰æ•ˆçš„è¿ç®—ç¬¦åŒ…æ‹¬Â +,Â -,Â *,Â /Â ã€‚æ¯ä¸ªè¿ç®—å¯¹è±¡å¯ä»¥æ˜¯æ•´æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯å¦ä¸€ä¸ªé€†æ³¢å…°è¡¨è¾¾å¼ã€‚
è¯´æ˜ï¼š
æ•´æ•°é™¤æ³•åªä¿ç•™æ•´æ•°éƒ¨åˆ†ã€‚
ç»™å®šé€†æ³¢å…°è¡¨è¾¾å¼æ€»æ˜¯æœ‰æ•ˆçš„ã€‚æ¢å¥è¯è¯´ï¼Œè¡¨è¾¾å¼æ€»ä¼šå¾—å‡ºæœ‰æ•ˆæ•°å€¼ä¸”ä¸å­˜åœ¨é™¤æ•°ä¸º 0 çš„æƒ…å†µã€‚
### ç¤ºä¾‹
```
è¾“å…¥: ["2", "1", "+", "3", "*"]
è¾“å‡º: 9
è§£é‡Š: è¯¥ç®—å¼è½¬åŒ–ä¸ºå¸¸è§çš„ä¸­ç¼€ç®—æœ¯è¡¨è¾¾å¼ä¸ºï¼š((2 + 1) * 3) = 9
```
### è§£é¢˜æ€è·¯
* å…¸å‹çš„åç¼€è¡¨è¾¾å¼ï¼Œæ ˆå¾—åº”ç”¨åœºæ™¯
* éå†å­—ç¬¦ä¸²æ•°ç»„ï¼Œé‡åˆ°å­—ç¬¦å°±å¼¹å‡ºæ ˆé¡¶ä¸¤ä¸ªå…ƒç´ è¿›è¡Œè¿ç®—ï¼Œå†å°†ç»“æœå¡«å…¥æ ˆã€‚é‡åˆ°æ•°å­—å°±ç›´æ¥å…¥æ ˆ
* è¿™é‡Œä½¿ç”¨äº†cè¯­è¨€`stoi()`å‡½æ•°ç›´æ¥å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºæ•°å­—ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ASCIIå€¼è½¬ï¼Œ`atoi(string.c_str())`
```cpp
    int evalRPN(vector<string>& tokens) {
        stack<int> sck;
        for (auto it : tokens) {
            if (it == "+") {
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(b + a);
            } else if (it == "-") {
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(b - a);
            } else if (it == "*"){
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(a * b);
            } else if (it == "/"){
                int a = sck.top();
                sck.pop();
                int b = sck.top();
                sck.pop();
                sck.push(b / a);
            } else {
                sck.push(stoi(it));
            }
        }
        return sck.top();
    }
```

å­—ç¬¦ä¸²è§£ç 
==========
[leetcode](https://leetcode-cn.com/problems/decode-string/)ç»™å®šä¸€ä¸ªç»è¿‡ç¼–ç çš„å­—ç¬¦ä¸²ï¼Œè¿”å›å®ƒè§£ç åçš„å­—ç¬¦ä¸²ã€‚
ç¼–ç è§„åˆ™ä¸º: k[encoded_string]ï¼Œè¡¨ç¤ºå…¶ä¸­æ–¹æ‹¬å·å†…éƒ¨çš„ encoded_string æ­£å¥½é‡å¤ k æ¬¡ã€‚æ³¨æ„ k ä¿è¯ä¸ºæ­£æ•´æ•°ã€‚
ä½ å¯ä»¥è®¤ä¸ºè¾“å…¥å­—ç¬¦ä¸²æ€»æ˜¯æœ‰æ•ˆçš„ï¼›è¾“å…¥å­—ç¬¦ä¸²ä¸­æ²¡æœ‰é¢å¤–çš„ç©ºæ ¼ï¼Œä¸”è¾“å…¥çš„æ–¹æ‹¬å·æ€»æ˜¯ç¬¦åˆæ ¼å¼è¦æ±‚çš„ã€‚
æ­¤å¤–ï¼Œä½ å¯ä»¥è®¤ä¸ºåŸå§‹æ•°æ®ä¸åŒ…å«æ•°å­—ï¼Œæ‰€æœ‰çš„æ•°å­—åªè¡¨ç¤ºé‡å¤çš„æ¬¡æ•° k ï¼Œä¾‹å¦‚ä¸ä¼šå‡ºç°åƒÂ 3aÂ æˆ–Â 2[4]Â çš„è¾“å…¥ã€‚
### ç¤ºä¾‹
```
è¾“å…¥ï¼šs = "3[a]2[bc]"
è¾“å‡ºï¼š"aaabcbc"

è¾“å…¥ï¼šs = "3[a2[c]]"
è¾“å‡ºï¼š"accaccacc"
```
### è§£é¢˜æ€è·¯
* ä¸€çœ‹åˆ°`[` `]` åŒ¹é…å¾—é¢˜ï¼Œé¦–å…ˆæƒ³åˆ°ä½¿ç”¨æ ˆï¼Œæ—¢æœ‰æ•°å­—åˆæœ‰å­—æ¯ï¼Œæƒ³åˆ°ä½¿ç”¨ä¸¤ä¸ªæ ˆ
* è¿™ç±»é¢˜åŸºæœ¬æ€è·¯å°±æ˜¯æ‰¾åˆ°ä»€ä¹ˆæ—¶å€™å…¥æ ˆï¼Œä»€ä¹ˆæ—¶å€™å‡ºæ ˆã€‚
* åŒæ—¶æ¶‰åŠäº†éå†æ•°ç»„ï¼Œæå–æ•°å­—å’Œæå–å­—ç¬¦ä¸²ç®—æ³•
* æœ¬é¢˜çš„å½“éå†åˆ°'['æ—¶åŒæ—¶å…¥æ ˆï¼Œéå†åˆ°']'æ—¶å‡ºæ ˆè¿›è¡Œæ“ä½œ,strSck.top()å¯ä»¥ç†è§£ä¸ºåˆ°å½“å‰ä¸ºæ­¢å‰é¢å·²ç»å±•å¼€çš„å­—ç¬¦ä¸²ï¼Œcurä¸ºåˆšåˆš`[ ]`ä¸­åˆæˆçš„å­—ç¬¦ä¸²ã€‚
* è®²é“ç†æ­¤é¢˜è¿‡äºéš¾ä»¥ç†è§£ğŸ›
```cpp
    string decodeString(string s) {
        string cur = "";
        stack<int> numSck;
        stack<string> strSck;
        int val = 0;
        for (int i = 0; s[i] != '\0'; ++i) {
            if (s[i] >= '0' && s[i] <= '9') {
                val = val * 10 + s[i] - '0';
            } else if (s[i] == '[') {
                numSck.push(val);
                strSck.push(cur);
                val = 0;
                cur = "";
            } else if ((s[i] >= 'a' && s[i] <='z') || (s[i] >= 'A' && s[i] <= 'Z')) {
                cur += s[i];
            } else if (s[i] == ']') {
                int cnt = numSck.top();
                numSck.pop();
                for (int i = 0; i < cnt; ++i) {
                    strSck.top() += cur;
                }
                cur = strSck.top();
                strSck.pop();
            }
        }
        return cur;
    }
```

å…‹éš†å›¾
========
[leetcode](https://leetcode-cn.com/problems/clone-graph/)ç»™ä½ æ— å‘ è¿é€š å›¾ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„å¼•ç”¨ï¼Œè¯·ä½ è¿”å›è¯¥å›¾çš„ æ·±æ‹·è´ï¼ˆå…‹éš†ï¼‰ã€‚
å›¾ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½åŒ…å«å®ƒçš„å€¼` val  int` å’Œå…¶é‚»å±…çš„åˆ—è¡¨`vector[Node]`ã€‚
### ç¤ºä¾‹
```
è¾“å…¥ï¼šadjList = [[2,4],[1,3],[2,4],[1,3]]
è¾“å‡ºï¼š[[2,4],[1,3],[2,4],[1,3]]
è§£é‡Šï¼š
å›¾ä¸­æœ‰ 4 ä¸ªèŠ‚ç‚¹ã€‚
èŠ‚ç‚¹ 1 çš„å€¼æ˜¯ 1ï¼Œå®ƒæœ‰ä¸¤ä¸ªé‚»å±…ï¼šèŠ‚ç‚¹ 2 å’Œ 4 ã€‚
èŠ‚ç‚¹ 2 çš„å€¼æ˜¯ 2ï¼Œå®ƒæœ‰ä¸¤ä¸ªé‚»å±…ï¼šèŠ‚ç‚¹ 1 å’Œ 3 ã€‚
èŠ‚ç‚¹ 3 çš„å€¼æ˜¯ 3ï¼Œå®ƒæœ‰ä¸¤ä¸ªé‚»å±…ï¼šèŠ‚ç‚¹ 2 å’Œ 4 ã€‚
èŠ‚ç‚¹ 4 çš„å€¼æ˜¯ 4ï¼Œå®ƒæœ‰ä¸¤ä¸ªé‚»å±…ï¼šèŠ‚ç‚¹ 1 å’Œ 3 ã€‚

```
### è§£é¢˜æ€è·¯
* å›¾å¾—éå†æœ‰ä¸¤ç§æ·±åº¦DFSå’Œå¹¿åº¦BFS
* æ·±åº¦ä¼˜å…ˆéå†ï¼šä½¿ç”¨é€’å½’åŒæ—¶è¿˜éœ€è¦è®°å½•å“ªäº›æ˜¯å·²ç»å¤åˆ¶è¿‡å¾—ï¼Œå‡½æ•°å¾—æ„ä¹‰æ˜¯å¤åˆ¶å¹¶è¿”å›å¤åˆ¶å¾—ç»“ç‚¹ï¼Œå¦‚æœå‘ç°è¯¥ç»“ç‚¹å·²ç»å¤åˆ¶è¿‡ï¼Œç›´æ¥è¿”å›å¤åˆ¶å¾—ç»“ç‚¹
* ç”±äºæ˜¯æ·±æ‹·è´ï¼Œä¸€å®šéœ€è¦newï¼Œæ‰€ä»¥è¯¥ç»“ç‚¹æ²¡æœ‰å¤åˆ¶ï¼Œå°±newä¸€ä¸ªæ–°ç»“ç‚¹ï¼Œå¹¶æ ‡è®°å·²ç»æ‹·è´è¿‡ã€‚
* æ–°å¾—ç»“ç‚¹è¿˜éœ€è¦é“¾æ¥å®ƒå¾—é‚»æ¥ç‚¹ï¼Œéå†å®ƒå¾—æ‰€ä»¥é‚»æ¥ç‚¹ï¼Œå¹¶ç»§ç»­å¤åˆ¶ã€‚
```cpp
    Node* isClone[101];
    Node* cloneGraph(Node* node) {
        if (node == NULL) return NULL;
        if (isClone[node->val] != NULL) return isClone[node->val];
        Node* newNode = new Node(node->val);
        isClone[node->val] = newNode;
        for (auto it : node->neighbors) {
            newNode->neighbors.push_back(cloneGraph(it));
        }
        return newNode;
    }
```
* ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†å°±å¿…é¡»ä½¿ç”¨é˜Ÿåˆ—
* é¦–å…ˆå…ˆå¤åˆ¶ç¬¬ä¸€ä¸ªç»“ç‚¹å¹¶åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ï¼Œç„¶åè¿›å…¥å¾ªç¯ï¼Œæ³¨æ„ï¼šé˜Ÿåˆ—åŠ å…¥å¾—éƒ½æ˜¯åŸç»“ç‚¹ä¸æ˜¯æ–°åˆ›å»ºå¾—ç»“ç‚¹ï¼Œå› ä¸ºæ–°ç»“ç‚¹è¿˜æ²¡æœ‰é“¾æ¥é‚»æ¥ç‚¹
* å¯¹æ¯ä¸ªå‡ºé˜Ÿåˆ—å¾—ç»“ç‚¹å¹¿åº¦éå†ï¼Œå³éå†å®Œå®ƒå¾—æ‰€æœ‰é‚»æ¥ç‚¹ï¼Œæ²¡æœ‰å¤åˆ¶è¿‡å¾—å°±æ–°å»ºå¹¶åŠ å…¥é˜Ÿåˆ—ï¼Œæœ€åé“¾æ¥æ–°å»ºçš„ç»“ç‚¹å’Œé‚»æ¥ç‚¹

```cpp
    Node* isClone[101];
    Node* cloneGraph(Node* node) {
        if (!node) return nullptr;
        queue<Node*> que;
        Node* newNode = new Node(node->val);
        isClone[node->val] = newNode;
        que.push(node);
        while (!que.empty()) {
	Node* cur = que.front();
	que.pop();
	for (Node* e : cur->neighbors) {
	       if (isClone[e->val] == NULL) {
		que.push(e);
		isClone[e->val] = new Node(e->val);
	       }
	       isClone[cur->val]->neighbors.push_back(isClone[e->val]);
	}
         }
         return newNode;
     }
```

å²›å±¿æ•°é‡
==========
[leetcode](https://leetcode-cn.com/problems/number-of-islands/)ç»™ä½ ä¸€ä¸ªç”±Â '1'ï¼ˆé™†åœ°ï¼‰å’Œ '0'ï¼ˆæ°´ï¼‰ç»„æˆçš„çš„äºŒç»´ç½‘æ ¼ï¼Œè¯·ä½ è®¡ç®—ç½‘æ ¼ä¸­å²›å±¿çš„æ•°é‡ã€‚
å²›å±¿æ€»æ˜¯è¢«æ°´åŒ…å›´ï¼Œå¹¶ä¸”æ¯åº§å²›å±¿åªèƒ½ç”±æ°´å¹³æ–¹å‘æˆ–ç«–ç›´æ–¹å‘ä¸Šç›¸é‚»çš„é™†åœ°è¿æ¥å½¢æˆã€‚
æ­¤å¤–ï¼Œä½ å¯ä»¥å‡è®¾è¯¥ç½‘æ ¼çš„å››æ¡è¾¹å‡è¢«æ°´åŒ…å›´ã€‚
### ç¤ºä¾‹
```
è¾“å…¥:
[
['1','1','1','1','0'],
['1','1','0','1','0'],
['1','1','0','0','0'],
['0','0','0','0','0']
]
è¾“å‡º:Â 1
```
### DFSè§£é¢˜æ€è·¯
* æŠŠäºŒç»´è¡¨æ ¼å½“ä½œä¸€ä¸ªå›¾æ¥å¤„ç†ï¼Œæ¯ä¸ªç»“ç‚¹çš„ä¸Šä¸‹å·¦å³éƒ½æ˜¯å®ƒçš„é‚»æ¥ç‚¹
* ä¸¤ä¸ªforå¾ªç¯éå†äºŒç»´æ•°ç»„ï¼Œå½“é‡åˆ°`1`æ—¶å¼€å§‹æ·±åº¦éå†å®ƒçš„é‚»æ¥ç‚¹ï¼Œå‡¡æ˜¯dfséå†é€”ä¸­é‡åˆ°`1`çš„éƒ½æ”¹ä¸º0ï¼Œç›´åˆ°æ‰€æœ‰ç›¸è¿çš„1å…¨éƒ¨æ”¹ä¸º0ï¼Œè¿™å°±ç®—æ‰¾åˆ°äº†ä¸€ä¸ªå²›ï¼Œåé¢ç»§ç»­éå†æ”¹åçš„äºŒç»´æ•°ç»„ã€‚
```cpp
    int numIslands(vector<vector<char>>& grid) {
        int cnt = 0;
        for (int i = 0; i < grid.size(); ++i) {
            for (int j = 0; j < grid[0].size(); ++j) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    cnt++;
                }
            }
        }
        return cnt;
    }

    void dfs(vector<vector<char> >& grid, int x, int y) {
        int row = grid.szie() - 1;
        int col = grid[0].szie() - 1;
        grid[row][col] = '0';
        if (x < row && grid[x + 1][y] == '1') dfs(grid, x + 1, y);
        if (x > 0   && grid[x - 1][y] == '1') dfs(grid, x - 1, y);
        if (y < col && grid[x][y + 1] == '1') dfs(grid, x, y + 1);
        if (y > 0   && grid[x][y - 1] == '1') dfs(grid, x, y - 1);
    }
```
### BFSè§£é¢˜
* mdï¼Œè¶…å‡ºæ—¶é—´é™åˆ¶æ‰¾äº†ä¸€ä¸ªå¤šå°æ—¶çš„åŸå› ï¼Œä¸€ä¸ªå­—ä¸€ä¸ªå­—å¯¹æ¯”æœ€åæ‰å‘ç°ï¼Œä¸€ä¸ª`= `å†™æˆ`==`ï¼Œæ—¥å•Šã€‚ç¬¬äºŒæ¬¡çŠ¯è¿™ç§é”™è¯¯äº†
```cpp
    int numIslands(vector<vector<char>>& grid) {
        if (grid.empty()) return 0;
        int row = grid.size();
        int col = grid[0].size();
        int cnt = 0;
        queue<pair<int, int> > que;
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (grid[i][j] == '1') {
                    cnt++;
                    grid[i][j] = '0';
                    que.push(pair(i, j));
                    while (!que.empty()) {
                        pair<int, int> cur = que.front();
                        que.pop();
                        int x = cur.first;
                        int y = cur.second;
                        if (x - 1 >= 0  && grid[x - 1][y] == '1') {
                            grid[x - 1][y] = '0';
                            que.push(pair<int, int>(x - 1, y));
                        }  
                        if (y - 1 >= 0  && grid[x][y - 1] == '1') {
                            que.push(pair<int, int>(x, y - 1));
                            grid[x][y - 1] = '0';
                        }  
                        if (x + 1 < row && grid[x + 1][y] == '1') {
                            que.push(pair<int, int>(x + 1, y));
                            grid[x + 1][y] = '0';
                        }
                        if (x + 1 < row && grid[x + 1][y] == '1') {
                            que.push(pair<int, int>(x + 1, y));
                            grid[x + 1][y] = '0';
                        }
                        if (y + 1 < col && grid[x][y + 1] == '1') {
                            que.push(pair<int, int>(x, y + 1));
                            grid[x][y + 1] = '0';
                        }
                    }
                }
            }
        } 
        return cnt;
    }
```

æŸ±çŠ¶å›¾ä¸­æœ€å¤§çš„çŸ©å½¢
==============
[leetcode](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)ç»™å®š n ä¸ªéè´Ÿæ•´æ•°ï¼Œç”¨æ¥è¡¨ç¤ºæŸ±çŠ¶å›¾ä¸­å„ä¸ªæŸ±å­çš„é«˜åº¦ã€‚æ¯ä¸ªæŸ±å­å½¼æ­¤ç›¸é‚»ï¼Œä¸”å®½åº¦ä¸º 1 ã€‚
æ±‚åœ¨è¯¥æŸ±çŠ¶å›¾ä¸­ï¼Œèƒ½å¤Ÿå‹¾å‹’å‡ºæ¥çš„çŸ©å½¢çš„æœ€å¤§é¢ç§¯ã€‚
### ç¤ºä¾‹
[dd](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)
ä»¥ä¸Šæ˜¯æŸ±çŠ¶å›¾çš„ç¤ºä¾‹ï¼Œå…¶ä¸­æ¯ä¸ªæŸ±å­çš„å®½åº¦ä¸º 1ï¼Œç»™å®šçš„é«˜åº¦ä¸º [2,1,5,6,2,3]ã€‚
### è§£é¢˜æ€è·¯
* æš´åŠ›è§£æ³•å¯ä»¥æšä¸¾ä»¥æ¯ä¸ªæŸ±å½¢ä¸ºé«˜åº¦çš„æœ€å¤§çŸ©å½¢çš„é¢ç§¯ã€‚å…·ä½“æ¥è¯´å°±æ˜¯ï¼šä¾æ¬¡éå†æŸ±å½¢çš„é«˜åº¦ï¼Œå¯¹äºæ¯ä¸€ä¸ªé«˜åº¦åˆ†åˆ«å‘ä¸¤è¾¹æ‰©æ•£ï¼Œæ±‚å‡ºä»¥å½“å‰é«˜åº¦ä¸ºçŸ©å½¢çš„æœ€å¤§å®½åº¦å¤šå°‘ã€‚
* å·¦è¾¹çœ‹ä¸€ä¸‹ï¼Œçœ‹æœ€å¤šèƒ½å‘å·¦å»¶ä¼¸å¤šé•¿ï¼Œæ‰¾åˆ°å¤§äºç­‰äºå½“å‰æŸ±å½¢é«˜åº¦çš„æœ€å·¦è¾¹å…ƒç´ çš„ä¸‹æ ‡ï¼›
* å³è¾¹çœ‹ä¸€ä¸‹ï¼Œçœ‹æœ€å¤šèƒ½å‘å³å»¶ä¼¸å¤šé•¿ï¼›æ‰¾åˆ°å¤§äºç­‰äºå½“å‰æŸ±å½¢é«˜åº¦çš„æœ€å³è¾¹å…ƒç´ çš„ä¸‹æ ‡ã€‚
* ä»¥ä¸‹é¢˜è§£ä¼šè¶…æ—¶ã€‚
```cpp
    int largestRectangleArea(vector<int>& heights) {
        if (heights.empty()) return 0;
        int res = INT_MIN;
        for (int i = 0; i < heights.size(); ++i) {
            int left = i, right = i; 
            while (left > 0 && heights[left - 1] >= heights[i]) left--;
            while (right < heights.size() - 1 && heights[right + 1] >= heights[i]) right++;
            int len = right - left + 1;
            res = max(res, heights[i] * len);
        }
        return res;
    }
```

01çŸ©é˜µ
=========
[leetcode](https://leetcode-cn.com/problems/01-matrix/)
ç»™å®šä¸€ä¸ªç”± 0 å’Œ 1 ç»„æˆçš„çŸ©é˜µï¼Œæ‰¾å‡ºæ¯ä¸ªå…ƒç´ åˆ°æœ€è¿‘çš„ 0 çš„è·ç¦»ã€‚
ä¸¤ä¸ªç›¸é‚»å…ƒç´ é—´çš„è·ç¦»ä¸º 1 ã€‚
### ç¤ºä¾‹
```è¾“å…¥:

0 0 0
0 1 0
1 1 1
è¾“å‡º:

0 0 0
0 1 0
1 2 1
```
### è§£é¢˜æ€è·¯
* ç†è§£é¢˜æ„æ¯”è¾ƒéš¾ï¼Œé¢˜æ„è¦æ±‚æˆ‘ä»¬æ‰¾åˆ°æ¯ä¸ª1ç¦»0æœ€è¿‘çš„è·ç¦»ï¼Œæ­£å¸¸ä¼šæƒ³åˆ°éå†æ¯ä¸ª1ï¼Œæœ€æ¯ä¸ª1è¿›è¡ŒDFSæˆ–è€…BFSï¼Œä½†æ˜¯è¿™æ ·å°±æ¶‰åŠåˆ°å¯¹ä¸Šä¸‹å·¦å³æ¯ä¸ªåˆ†æ”¯çš„è·ç¦»æœ€çŸ­ç­›é€‰çš„æ“ä½œã€‚æ—¶é—´å¤æ‚åº¦ä¹Ÿä¼šå¤§å¤§å¢åŠ ã€‚
* å› æ­¤æˆ‘ä»¬å¯ä»¥åè¿‡æ¥éå†ï¼Œå…ˆéå†æ‰¾åˆ°æ‰€æœ‰0çš„ç»“ç‚¹ï¼Œä»–çš„4ä¸ªä¸Šä¸‹å·¦å³åˆ†æ”¯ç‚¹ä¸€å®šæ˜¯1ï¼Œè€Œ1çš„ä¸Šä¸‹å·¦å³4ä¸ªæœªè®¿é—®è¿‡çš„åˆ†æ”¯ç‚¹ä¸€å®šæ˜¯2ï¼Œä¾æ¬¡å±•å¼€ã€‚
* BFSè§£æ³•ä¸€èˆ¬éƒ½æ¶‰åŠé˜Ÿåˆ—çš„ä½¿ç”¨ï¼š
```cpp
    int off[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {
        int row = matrix.size();
        int col = matrix[0].size();
        // åˆå§‹åŒ–
        bool isVis[row][col];
        for (int i = 0; i < row; ++i) {
            memset(isVis[i], 0, col);
        }
        // å…¥é˜Ÿåˆ—çš„é¡ºåºï¼šæ‰€æœ‰0çš„ä½ç½®ï¼Œæ‰€æœ‰ç¦»0ç‚¹è·ç¦»ä¸º1çš„ç‚¹ï¼Œæ‰€æœ‰ç¦»0ç‚¹è·ç¦»ä¸º2çš„ç‚¹....
        queue<pair<int, int>> que;
        for (int i = 0; i < row; ++i) {
            for (int j = 0; j < col; ++j) {
                if (matrix[i][j] == 0) {
                    que.push({i, j});
                    isVis[i][j] = true;
                }
            }
        }
        
        while (!que.empty()) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for (int i = 0; i < 4; ++i) {
                int xi = x + off[i][0];
                int yi = y + off[i][1];
                if (xi >= 0 && xi < row && yi >= 0 && yi < col && !isVis[xi][yi]) {
                    isVis[xi][yi] = true;
                    matrix[xi][yi] = matrix[x][y] + 1; 
                    que.push({xi, yi});
                }
            }
        }
        return matrix;
    }
```

è®¾è®¡å¾ªç¯é˜Ÿåˆ—
=============
[leetcode](https://leetcode-cn.com/problems/design-circular-queue/)è®¾è®¡ä½ çš„å¾ªç¯é˜Ÿåˆ—å®ç°ã€‚ å¾ªç¯é˜Ÿåˆ—æ˜¯ä¸€ç§çº¿æ€§æ•°æ®ç»“æ„ï¼Œå…¶æ“ä½œè¡¨ç°åŸºäº FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰åŸåˆ™å¹¶ä¸”é˜Ÿå°¾è¢«è¿æ¥åœ¨é˜Ÿé¦–ä¹‹åä»¥å½¢æˆä¸€ä¸ªå¾ªç¯ã€‚å®ƒä¹Ÿè¢«ç§°ä¸ºâ€œç¯å½¢ç¼“å†²å™¨â€ã€‚

å¾ªç¯é˜Ÿåˆ—çš„ä¸€ä¸ªå¥½å¤„æ˜¯æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™ä¸ªé˜Ÿåˆ—ä¹‹å‰ç”¨è¿‡çš„ç©ºé—´ã€‚åœ¨ä¸€ä¸ªæ™®é€šé˜Ÿåˆ—é‡Œï¼Œä¸€æ—¦ä¸€ä¸ªé˜Ÿåˆ—æ»¡äº†ï¼Œæˆ‘ä»¬å°±ä¸èƒ½æ’å…¥ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå³ä½¿åœ¨é˜Ÿåˆ—å‰é¢ä»æœ‰ç©ºé—´ã€‚ä½†æ˜¯ä½¿ç”¨å¾ªç¯é˜Ÿåˆ—ï¼Œæˆ‘ä»¬èƒ½ä½¿ç”¨è¿™äº›ç©ºé—´å»å­˜å‚¨æ–°çš„å€¼ã€‚
ä½ çš„å®ç°åº”è¯¥æ”¯æŒå¦‚ä¸‹æ“ä½œï¼š
```
MyCircularQueue(k): æ„é€ å™¨ï¼Œè®¾ç½®é˜Ÿåˆ—é•¿åº¦ä¸º k ã€‚
Front: ä»é˜Ÿé¦–è·å–å…ƒç´ ã€‚å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› -1 ã€‚
Rear: è·å–é˜Ÿå°¾å…ƒç´ ã€‚å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› -1 ã€‚
enQueue(value): å‘å¾ªç¯é˜Ÿåˆ—æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœæˆåŠŸæ’å…¥åˆ™è¿”å›çœŸã€‚
deQueue(): ä»å¾ªç¯é˜Ÿåˆ—ä¸­åˆ é™¤ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœæˆåŠŸåˆ é™¤åˆ™è¿”å›çœŸã€‚
isEmpty(): æ£€æŸ¥å¾ªç¯é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚
isFull(): æ£€æŸ¥å¾ªç¯é˜Ÿåˆ—æ˜¯å¦å·²æ»¡ã€‚
```
### è§£é¢˜æ€è·¯
* ä¸¤ä¸ªæŒ‡é’ˆï¼Œ`head`å’Œ`tail`ï¼Œæ³¨æ„æ»¡é˜Ÿå’Œç©ºé˜Ÿçš„æ¡ä»¶ï¼Œæ»¡é˜Ÿæ—¶ï¼š`tail`å°±åœ¨`head`çš„å‰ä¸€æ ¼ï¼Œç©ºé˜Ÿæ—¶ï¼š`tail`å’Œ`head`éƒ½æŒ‡å‘-1ã€‚
* å‡¡æ¶‰åŠåˆ°å¾ªç¯ï¼ŒæŒ‡é’ˆç§»åŠ¨åéƒ½è¦å¯¹`size`å–æ¨¡æ‰èƒ½ä¿è¯ä¸è¶…è¿‡`size`å¤§å°ã€‚
```cpp
class MyCircularQueue {
private:
    vector<int> data;
    int size;
    int head;
    int tail;

public:
    MyCircularQueue(int k) {
        data.resize(k);
        size = k;
        head = -1;
        tail = -1;
    }
    
    bool enQueue(int value) {
        if (isFull()) return false;
        if (isEmpty()) head = 0;
        tail = (tail + 1) % size;
        data[tail] = value;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        if (head == tail) {     // åªå‰©ä¸€ä¸ªå…ƒç´ æ—¶
            head = -1;
            tail = -1;
            return true;
        }
        head = (head + 1) % size;
        return true;
    }
    
    int Front() {
        if (isEmpty()) return -1;
        return data[head];
    }
    
    int Rear() {
        if (isEmpty()) return -1;
        return data[tail];
    }
    
    bool isEmpty() {
        return head == -1;
    }
    
    bool isFull() {
        return (tail + 1) % size == head;
    }
};
```